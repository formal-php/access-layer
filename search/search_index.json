{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Getting started","text":"<p>This library is designed to eliminate state wherever possible when dealing with a database connection.</p> <p>The result is an api that consist of only one method on the connection (<code>__invoke</code>) and one kind of argument (<code>Query</code>). Both can easily be extended through composition.</p> <p>You must use <code>vimeo/psalm</code> to make sure you use this library correctly.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>composer require formal/access-layer\n</code></pre>"},{"location":"#basic-usage","title":"Basic usage","text":"<pre><code>use Formal\\AccessLayer\\{\n    Connection\\PDO,\n    Query\\SQL,\n    Row,\n};\nuse Innmind\\Url\\Url;\nuse Innmind\\Immutable\\Sequence;\n\n$connection = PDO::of(Url::of('mysql://user:pwd@127.0.0.1:3306/database_name'));\n\n$rows = $connection(SQL::of('SELECT * FROM `some_table`'));\n$rows; // instanceof Sequence&lt;Row&gt;\n</code></pre>"},{"location":"connections/lazy/","title":"<code>Lazy</code>","text":"<p>This is an abstraction on top of the <code>PDO</code> connection that will establish a connection to the database upon executing the first query.</p> <p>This is useful because you can create a database connection object at the start of your script and it will never connect to the database if you never use the connection.</p> <pre><code>use Formal\\AccessLayer\\{\n    Connection\\Lazy,\n    Connection\\PDO,\n};\nuse Innmind\\Url\\Url;\n\n$connection = Lazy::of(\n    static fn() =&gt; PDO::of(\n        Url::of('mysql://user:pwd@127.0.0.1:3306/database_name'),\n    ),\n);\n</code></pre> <p>By passing a callable to the constructor it allows you to use whatever implementation of a <code>Connection</code> you wish to lazy load.</p>"},{"location":"connections/logger/","title":"<code>Logger</code>","text":"<p>This connection sits on top of another and will log all queries that will be executed and record any failure that may occur.</p> <pre><code>use Formal\\AccessLayer\\{\n    Connection\\Logger,\n    Connection,\n};\nuse Psr\\Log\\LoggerInterface;\n\n$connection = Logger::psr(\n    /* any instance of Connection */,\n    /* any instance of LoggerInterface */,\n);\n</code></pre> <p>It doesn't log any information about the returned rows to prevent unwrapping the deferred <code>Sequence</code> returned by <code>PDO</code>.</p> <p>It won't log any errors for lazy queries since the query is not executed until the first call on the sequence.</p>"},{"location":"connections/own/","title":"Create your own","text":"<p>You can easily create your own connection to extend the behaviour of this library.</p> <p>For example you could implement a connection that will send any failure to sentry like so:</p> <pre><code>use Formal\\AccessLayer\\{\n    Connection,\n    Query,\n};\nuse Innmind\\Immutable\\Sequence;\nuse Sentry\\ClientInterface;\n\nfinal class Sentry implements Connection\n{\n    public function __construct(\n        private Connection $connection,\n        private ClientInterface $sentry,\n    ) {}\n\n    public function __invoke(Query $query): Sequence\n    {\n        try {\n            return ($this-&gt;connection)($query);\n        } catch (\\Throwable $e) {\n            $this-&gt;sentry-&gt;captureException($e);\n\n            throw $e;\n        }\n    }\n}\n</code></pre>"},{"location":"connections/own/#testing-your-connection","title":"Testing your connection","text":"<p>An important part of extending the behaviour of the connection with your own logic is to not change the current behaviour that other code may rely upon. This library helps you make sure you don't break these behaviours by providing you properties.</p> <p>Below is an example of running properties via BlackBox:</p> <pre><code>use Innmind\\BlackBox\\Set;\nuse Properties\\Formal\\AccessLayer\\Connection as Properties;\n\n$sentry = new Sentry(/* add the arguments of your implementation here */);\n$connection = Set\\Call::of(static function() use ($sentry) {\n    Properties::seed($sentry);\n\n    return $sentry;\n});\n\nyield properties(\n    'Sentry properties',\n    Properties::any(),\n    $connection,\n);\n\nforeach (Properties::list() as $property) {\n    yield property(\n        $property,\n        $connection,\n    )-&gt;named('Sentry');\n}\n</code></pre> <p>This will ensure that your implementation hold all the properties that must be held by all the connection implementations so you can swap the implementations without side effects.</p>"},{"location":"connections/pdo/","title":"<code>PDO</code>","text":"<p>This is the basic connection from this library which is a simple abstraction on top of PHP builtin <code>\\PDO</code> class.</p> <p>To build an instance of it you only need the dsn to your database:</p> MySQL/MariaDBPostgreSQL <pre><code>use Formal\\AccessLayer\\Connection\\PDO;\nuse Innmind\\Url\\Url;\n\n$connection = PDO::of(\n    Url::of('mysql://user:pwd@127.0.0.1:3306/database_name?charset=utf8mb4')\n);\n</code></pre> <pre><code>use Formal\\AccessLayer\\Connection\\PDO;\nuse Innmind\\Url\\Url;\n\n$connection = PDO::of(\n    Url::of('pgsql://user:pwd@127.0.0.1:5432/database_name?charset=utf8mb4')\n);\n</code></pre> <p>When executing a query through this connection it will return a deferred <code>Sequence</code> of rows. This means that the rows returned from the database are only loaded once you iterate over the sequence. (Queries with the named constructor <code>::onDemand()</code> will return a lazy <code>Sequence</code>).</p> <p>As soon as you instanciate the class it will open a connection to the database, if you want to open it upon first query take a look at the <code>Lazy</code> connection.</p>"},{"location":"queries/create_table/","title":"<code>CreateTable</code>","text":"<pre><code>use Formal\\AccessLayer\\{\n    Query\\CreateTable,\n    Table\\Name,\n    Table\\Column,\n};\n\n$create = CreateTable::named(\n    Name::of('users'),\n    Column::of(\n        Column\\Name::of('username'),\n        Column\\Type::varchar(),\n    ),\n    Column::of(\n        Column\\Name::of('name'),\n        Column\\Type::varchar(),\n    ),\n);\n$connection($create);\n</code></pre> <p>This query will fail if the table does exist, you can prevent this like so:</p> <pre><code>use Formal\\AccessLayer\\{\n    Query\\CreateTable,\n    Table\\Name,\n    Table\\Column,\n};\n\n$create = CreateTable::ifNotExists(\n    Name::of('users'),\n    Column::of(\n        Column\\Name::of('username'),\n        Column\\Type::varchar(),\n    ),\n    Column::of(\n        Column\\Name::of('name'),\n        Column\\Type::varchar(),\n    ),\n);\n$connection($create);\n</code></pre>"},{"location":"queries/create_table/#constraints","title":"Constraints","text":""},{"location":"queries/create_table/#primary-key","title":"Primary key","text":"<p>You can specify the primary key of the table like so:</p> <pre><code>$create = CreateTable::named(\n    Name::of('users'),\n    Column::of(\n        Column\\Name::of('id'),\n        Column\\Type::int(),\n    ),\n);\n$create = $create-&gt;primaryKey(Column\\Name::of('id'));\n$connection($create);\n</code></pre>"},{"location":"queries/create_table/#foreign-key","title":"Foreign key","text":"<pre><code>$create = CreateTable::named(\n    Name::of('address'),\n    Column::of(\n        Column\\Name::of('user'),\n        Column\\Type::int(),\n    ),\n    Column::of(\n        Column\\Name::of('address'),\n        Column\\Type::text(),\n    ),\n);\n$create = $create-&gt;foreignKey(\n    Column\\Name::of('user'),\n    Name::of('users'),\n    Column\\Name::of('id'),\n);\n$connection($create);\n</code></pre> <p>This will name the foreign key <code>FK_user_id</code> so it's easier to reference it afterwards.</p>"},{"location":"queries/delete/","title":"<code>Delete</code>","text":"<pre><code>use Formal\\AccessLayer\\{\n    Query\\Delete,\n    Table\\Name,\n};\n\n$delete = Delete::from(Name::of('users'));\n$connection($delete);\n</code></pre> <p>This example will all the users of the table.</p>"},{"location":"queries/delete/#specify-rows-to-delete","title":"Specify rows to delete","text":"<p>To filter the rows to delete this library uses the specification pattern.</p> <pre><code>use Formal\\AccesLayer\\{\n    Query\\Delete,\n    Table\\Name,\n};\nuse Innmind\\Specification\\{\n    Comparator\\Property,\n    Sign,\n};\n\nfinal class Username\n{\n    public static function of(string $value): Property\n    {\n        return Property::of(\n            'username', // this is the name of the column\n            Sign::equality,\n            $value,\n        );\n    }\n}\n\n$delete = Delete::from(Name::of('users'))-&gt;where(\n    Username::of('some username')-&gt;or(Username::of('other username')),\n);\n$connection($delete);\n</code></pre> <p>The property name can include the name of the table to match by using the format <code>'{table}.{column}'</code>.</p>"},{"location":"queries/drop_table/","title":"<code>DropTable</code>","text":"<pre><code>use Formal\\AccessLayer\\{\n    Query\\DropTable,\n    Table\\Name,\n};\n\n$drop = DropTable::named(Name::of('users'));\n$connection($drop);\n</code></pre> <p>This query will fail if the table doesn't exist, you can prevent this like so:</p> <pre><code>use Formal\\AccessLayer\\{\n    Query\\DropTable,\n    Table\\Name,\n};\n\n$drop = DropTable::ifExists(Name::of('users'));\n$connection($drop);\n</code></pre>"},{"location":"queries/insert/","title":"<code>Insert</code>","text":"<pre><code>use Formal\\AccessLayer\\{\n    Query\\Insert,\n    Query\\Parameter,\n    Table\\Name,\n    Row,\n};\n\n$insert = Insert::into(\n    Name::of('users'),\n    Row::of([\n        'username' =&gt; 'some username',\n        'name' =&gt; 'some name',\n    ]),\n);\n$connection($insert);\n</code></pre> <p>If you need to specify the type of the values you want to insert you can do like this:</p> <pre><code>use Formal\\AccessLayer\\{\n    Query\\Insert,\n    Query\\Parameter,\n    Query\\Parameter\\Type,\n    Table\\Name,\n    Table\\Column,\n    Row,\n};\n\n$insert = Insert::into(\n    Name::of('users'),\n    Row::new(\n        Row\\Value::of(\n            Column\\Name::of('username'),\n            'some username',\n            Type::string,\n        ),\n        Row\\Value::of(\n            Column\\Name::of('name'),\n            'some name',\n            Type::string,\n        ),\n    ),\n);\n$connection($insert);\n</code></pre>"},{"location":"queries/insert/#multiple-inserts","title":"Multiple inserts","text":"<p><code>Insert</code> allows you to insert a single row at a time. This forces you to run multiple queries which can be slow, but allows you to specify different columns for each row inserted.</p> <p>Instead you can use <code>MultipleInsert</code>:</p> <pre><code>use Formal\\AccessLayer\\{\n    Query\\MultipleInsert,\n    Table\\Name,\n    Table\\Column,\n    Row,\n};\nuse Innmind\\Immutable\\Sequence;\n\n$insert = MultipleInsert::into(\n    Name::of('users'),\n    Column\\Name::of('username'),\n    Column\\Name::of('name'),\n);\n$connection($insert(Sequence::of(\n    Row::of([\n        'username' =&gt; 'john',\n        'name' =&gt; 'John Doe',\n    ]),\n    Row::of([\n        'username' =&gt; 'jane',\n        'name' =&gt; 'Jane Doe',\n    ]),\n)));\n</code></pre> <p>Each <code>Row</code> must specify the same amount of columns and in the same order, otherwise it will fail.</p>"},{"location":"queries/insert/#select-insert","title":"Select insert","text":"<p><code>Insert</code> allows you to insert multiple values at once coming from another table via a <code>Select</code> query.</p> <pre><code>use Formal\\AccessLayer\\{\n    Query\\Insert,\n    Query\\Select,\n    Table\\Name,\n    Table\\Column,\n};\n$insert = Insert::into(\n    Name::of('users'),\n    Select::from('leads')-&gt;columns(\n        Column\\Name::of('username'),\n        Column\\Name::of('name'),\n    ),\n);\n\n$connection($insert);\n</code></pre> <p>This example copies all <code>leads</code> as new <code>users</code>.</p>"},{"location":"queries/select/","title":"<code>Select</code>","text":"<pre><code>use Formal\\AccesLayer\\{\n    Query\\Select,\n    Table\\Name,\n};\n\n$select = Select::from(Name::of('users'));\n$users = $connection($select);\n</code></pre> <p>This will return all the content of the <code>users</code> table.</p> <p>If you replace the constructor <code>::from()</code> by <code>::onDemand()</code> it will run your query lazily by returning a lazy <code>Sequence</code>, meaning it won't keep the results in memory allowing you to handle very large results.</p>"},{"location":"queries/select/#specifying-columns-to-return","title":"Specifying columns to return","text":"<pre><code>use Formal\\AccesLayer\\{\n    Query\\Select,\n    Table\\Name,\n    Table\\Column,\n};\n\n$select = Select::from(Name::of('users'))-&gt;columns(\n    Column\\Name::of('username'),\n    Column\\Name::of('name'),\n);\n$users = $connection($select);\n</code></pre>"},{"location":"queries/select/#filter-rows","title":"Filter rows","text":"<p>To filter the rows to select this library uses the specification pattern.</p> <pre><code>use Formal\\AccesLayer\\{\n    Query\\Select,\n    Table\\Name,\n    Table\\Column,\n};\nuse Innmind\\Specification\\{\n    Comparator\\Property,\n    Sign,\n};\n\nfinal class Username\n{\n    public static function of(string $username): Property\n    {\n        return Property::of(\n            'username', // this is the name of the column,\n            Sign::equality,\n            $username,\n        );\n    }\n}\n\n$select = Select::from(Name::of('users'))-&gt;where(\n    Username::of('some username')-&gt;or(Username::of('other username')),\n);\n$users = $connection($select);\n</code></pre> <p>The property name can include the name of the table to match by using the format <code>'{table}.{column}'</code>.</p> <p>The value of the specification can also be a query (this will translated to a sub query).</p>"},{"location":"queries/select/#select-inline-values","title":"Select inline values","text":"<p>On top of specifying the columns to fetch from the table you can specify values as virtual columns. This is very useful when using a <code>Select</code> to insert multiple values at once.</p> <pre><code>use Formal\\AccesLayer\\{\n    Query\\Select,\n    Table\\Name,\n    Table\\Column,\n    Row,\n};\n\n$select = Select::from(Name::of('users'))-&gt;columns(\n    Column\\Name::of('id'),\n    Row\\Value::of(\n        Column\\Name::of('score'),\n        0,\n    ),\n);\n</code></pre> <p>This will return as many rows as you have users and with a <code>0</code> in the <code>score</code> column.</p> <p>You could use this query to populate a new table <code>users_score</code>.</p> Warning <p>PostgreSQL is more strict than MySQL when specifying inline strings. It will fail when it deems strings to not be valid utf8 strings.</p> <p>Initially this feature was tested against any unicode string but PostgreSQL would regularly fail on some of them. It may only be some character blocks that cause problems. But for the time being it's now only tested on alphanumerical characters.</p>"},{"location":"queries/sql/","title":"<code>SQL</code>","text":"<p>This is the most basic way to execute a query through a connection.</p> <pre><code>use Formal\\AccessLayer\\{\n    Query\\SQL,\n    Row,\n};\n\n$query = SQL::of('SHOW TABLES');\n$tables = $connection($query);\n$tables-&gt;foreach(function(Row $row): void {\n    echo $row-&gt;column('Tables_in_database_name')-&gt;match(\n        static fn($name) =&gt; $name,\n        static fn() =&gt; '',\n    );\n});\n</code></pre> <p>If you replace the constructor <code>::of()</code> by <code>::onDemand()</code> it will run your query lazily by returning a lazy <code>Sequence</code>, meaning it won't keep the results in memory allowing you to handle very large results. This is particularly useful for <code>SELECT</code> queries.</p>"},{"location":"queries/sql/#parameters","title":"Parameters","text":"<p>For some queries you will need to specify parameters to provide values, you can bind them either by specifying their name or by an index</p> <p>Do not copy the values directly in the sql query as you'll be vulnerable to sql injection.</p>"},{"location":"queries/sql/#bound-by-name","title":"Bound by name","text":"<p>This is useful when you use the same parameter multiple times in your query.</p> <pre><code>use Formal\\AccessLayer\\Query\\Parameter;\n\n$insert = SQL::of(\n    'INSERT INTO `users` (`username`, `name`) VALUES (:username, :username)',\n);\n$insert = $insert-&gt;with(Parameter::named('username', 'some username value'));\n$connection($insert);\n</code></pre>"},{"location":"queries/sql/#bound-by-index","title":"Bound by index","text":"<p>This is the most simple approach as you only have to worry that you add the parameters in the order specified in the sql query.</p> <pre><code>use Formal\\AccessLayer\\Query\\Parameter;\n\n$insert = SQL::of('INSERT INTO `users` (`username`, `name`) VALUES (?, ?)');\n$insert = $insert\n    -&gt;with(Parameter::of('some username value'))\n    -&gt;with(Parameter::of('some name'));\n$connection($insert);\n</code></pre> <p>Traditionally the index value rely on the user (you) to be specified (see <code>PDOStatement::bindValue</code>), but this increase the probability for you to make an error. This problem is resolved here as the order in which the parameters are provided is always respected, this allows the connection to correctly provide the index to <code>\\PDO</code>.</p>"},{"location":"queries/transactions/","title":"Transactions","text":"<pre><code>use Formal\\AccessLayer\\Query\\{\n    StartTransaction,\n    Commit,\n    Rollback,\n};\n\ntry {\n    $connection(new StartTransaction);\n    $connection(/* any insert, update or delete query */);\n    $connection(new Commit);\n} catch (\\Throwable $e) {\n    $connection(new Rollback);\n\n    throw $e;\n}\n</code></pre>"},{"location":"queries/update/","title":"<code>Update</code>","text":"<pre><code>use Formal\\AccessLayer\\{\n    Query\\Update,\n    Table\\Name,\n    Row,\n};\n\n$update = Update::set(\n    Name::of('users'),\n    Row::of([\n        'name' =&gt; 'some value',\n    ]),\n);\n$connection($update);\n</code></pre> <p>This example will set the <code>name</code> to <code>some value</code> for all the users of the table.</p>"},{"location":"queries/update/#specify-rows-to-update","title":"Specify rows to update","text":"<p>To filter the rows to update this library uses the specification pattern.</p> <pre><code>use Formal\\AccesLayer\\{\n    Query\\Update,\n    Table\\Name,\n    Row,\n};\nuse Innmind\\Specification\\{\n    Comparator\\Property,\n    Sign,\n};\n\nfinal class Username\n{\n    public static function of(string $value): Property\n    {\n        return Property::of(\n            'username', // this is the name of the column\n            Sign::equality,\n            $value,\n        );\n    }\n}\n\n$update = Update::set(\n    Name::of('users'),\n    Row::of([\n        'name' =&gt; 'some value',\n    ]),\n);\n$update = $update-&gt;where(\n    Username::of('some username')-&gt;or(Username::of('other username')),\n);\n$connection($update);\n</code></pre> <p>The property name can include the name of the table to match by using the format <code>'{table}.{column}'</code>.</p>"}]}